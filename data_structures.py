# -*- coding: utf-8 -*-
"""data_structures.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vEmH-HYFAFlRoRTgAUAQDsY_UB6F8SEc
"""

import numpy as np
import timeit

!apt-get install libcairo2-dev libjpeg-dev libgif-dev
!pip install pycairo
import cairo

!pip install python-igraph
import igraph

def enumerate_matrix(gmat, i):
    gmat_row = gmat[i, :]
    indices_of_nonzero_columns = np.nonzero(gmat_row)[1]
    return indices_of_nonzero_columns.tolist()

import numpy as np
enumerate_matrix(np.matrix([[0,1],[1,0]]), 0)

def enumerate_adj_list(adj_list, i):
    return adj_list[i]

def enumerate_edge_list(edge_list, i):
    inds1 = np.where(edge_list[:,0] == i)[0]
    elems1 = edge_list[inds1, 1].tolist()
    inds2 = np.where(edge_list[:,1] == i)[0]
    elems2 = edge_list[inds2, 0].tolist()
    return np.unique(elems1 + elems2).tolist()

igraph.drawing.plot(igraph.Graph.Barabasi(5,3), bbox=[0,0,200,200])

def do_sim_ms(n):

    retlist = []

    nrep = 10
    nsubrep = 10

    # this is (sort of) a Python way of doing the R function "replicate":
    for _ in range(nrep):

        # make a random undirected graph with fixed (average) vertex degree = 5
        g = igraph.Graph.Barabasi(n, 5)

        # get the graph in three different representations
        g_matrix = np.matrix(g.get_adjacency().data)
        g_adj_list = g.get_adjlist()
        g_edge_list = np.array(g.get_edgelist())

        start_time = timeit.default_timer()

        for _ in range(nsubrep):
            for i in range(0, n):
                enumerate_matrix(g_matrix, i)

        matrix_elapsed = timeit.default_timer() - start_time

        start_time = timeit.default_timer()

        for _ in range(nsubrep):
             for i in range(0, n):
                enumerate_adj_list(g_adj_list, i)

        adjlist_elapsed = timeit.default_timer() - start_time

        start_time = timeit.default_timer()

        for _ in range(nsubrep):
             for i in range(0, n):
                enumerate_edge_list(g_edge_list, i)

        edgelist_elapsed = timeit.default_timer() - start_time

        retlist.append([matrix_elapsed, adjlist_elapsed, edgelist_elapsed])

        resarray = 1000.0 * np.mean(np.array(retlist), axis=0)/n

        resdict = {'adjacency matrix': resarray[0],
                   'adjacency list': resarray[1],
                   'edge list': resarray[2]}
        # average over replicates and then
        # divide by n so that the running time results are on a per-vertex basis
    return resdict

do_sim_ms(1000)

do_sim_ms(2000)

!pip install --only-binary=:all: bintrees
import bintrees

def find_matrix(gmat, i, j):
    return (gmat[i,j] == 1)

def find_adj_list(adj_list, i, j):
    return j in adj_list[i]

def find_edge_list(edge_list, i, j):
    return (([i,j] in edge_list) or ([j,i] in edge_list))

def find_bst_forest(bst_forest, i, j):
    return bst_forest[i].__contains__(j)

def get_bst_forest(theadjlist):
    g_adj_list = theadjlist
    n = len(g_adj_list)
    theforest = []
    for i in range(0,n):
        itree = bintrees.AVLTree()
        for j in g_adj_list[i]:
            itree.insert(j,1)
        theforest.append(itree)
    return theforest

def do_sim(n, k):

    retlist = []

    nrep = 1
    nsubrep = 1

    for _ in range(nrep):

        # make the random undirected graph
        g = igraph.Graph.Barabasi(n, k)

        # get the graph in three different representations
        g_matrix = np.matrix(g.get_adjacency().data)

        g_adj_list = g.get_adjlist()

        g_bst_forest = get_bst_forest(g_adj_list)

        start_time = timeit.default_timer()

        # inner loop only needs to go from i+1 to n, since the graph is undirected
        for _ in range(nsubrep):
            for i in range(0, n):
                for j in range(i+1, n):
                    find_matrix(g_matrix, i, j)

        matrix_elapsed = timeit.default_timer() - start_time

        start_time = timeit.default_timer()

        # inner loop only needs to go from i+1 to n, since the graph is undirected
        for _ in range(nsubrep):
            for i in range(0, n):
                for j in range(i+1, n):
                    find_adj_list(g_adj_list, i, j)

        adjlist_elapsed = timeit.default_timer() - start_time

        start_time = timeit.default_timer()

        # inner loop only needs to go from i+1 to n, since the graph is undirected
        for _ in range(nsubrep):
            for i in range(0, n):
                for j in range(i+1, n):
                    j in g_bst_forest[i]

        forest_elapsed = timeit.default_timer() - start_time

        retlist.append([matrix_elapsed, adjlist_elapsed, forest_elapsed])

        # get the results in seconds, and make sure to divide by number of vertex pairs
    return 1000000*np.mean(np.array(retlist), axis=0)/(n*(n-1)/2)

do_sim(1000, 5)

do_sim(1000, 10)

do_sim(1000, 20)

do_sim(1000, 50)

do_sim(1000, 100)